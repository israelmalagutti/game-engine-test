# Procedural Animation in 2D Games

This document is a deep-dive into procedural animation -- the art and science of generating movement algorithmically at runtime rather than drawing it frame by frame. It covers the full mathematical foundation, physics simulation techniques, and practical patterns you need to implement procedural animation from scratch in a 2D engine like this one.

This builds on the high-level overview in `DOCS.md` (Technique 4). Where that document introduced the concept, this one gives you everything you need to actually build it.

## Table of Contents
- [What "Procedural" Means in Game Animation](#1-what-procedural-means-in-game-animation)
- [Mathematical Foundations](#2-mathematical-foundations)
  - [Trigonometric Functions](#trigonometric-functions)
  - [Noise Functions](#noise-functions)
  - [Lerp, Smoothstep, and Easing](#lerp-smoothstep-and-easing)
- [Spring Physics -- Complete Theory and Implementation](#3-spring-physics----complete-theory-and-implementation)
- [Inverse Kinematics (IK) -- Full Explanation](#4-inverse-kinematics-ik----full-explanation)
- [Verlet Integration and Rope/Chain Physics](#5-verlet-integration-and-ropechain-physics)
- [Particle-Like Procedural Effects](#6-particle-like-procedural-effects)
- [Hybrid Approaches: Procedural + Pre-Made](#7-hybrid-approaches-procedural--pre-made)
- [Case Study: Rain World (Deep Analysis)](#8-case-study-rain-world-deep-analysis)
- [Case Study: Noita](#9-case-study-noita)
- [Implementation Patterns for Your Engine](#10-implementation-patterns-for-your-engine)

---

## 1. What "Procedural" Means in Game Animation

### Definition

"Procedural" means **generated by an algorithm at runtime** rather than stored as pre-made data. In the context of animation, it means that the position, rotation, scale, and shape of visual elements are computed mathematically each frame, rather than being read from a sequence of hand-drawn images.

A procedurally animated character might still use hand-drawn art for its body parts. The "procedural" part is how those parts are positioned and transformed. Think of it like a puppet show -- the puppet itself is a crafted artifact, but its movement is generated live by the puppeteer (your code).

### The Spectrum from Pre-Made to Fully Procedural

Animation techniques exist on a continuous spectrum:

```
Fully Pre-Made                                              Fully Procedural
     |                                                              |
     v                                                              v
 Frame-by-    Skeletal       Skeletal +     Procedural     Physics
 Frame        (authored      procedural     with static    simulation
 sprite       keyframes)     blending       art pieces     (no pre-made
 sheets                                                    art at all)
     |            |              |               |              |
  Stardew     Hollow         Ori and        Rain World      Noita (pixel
  Valley      Knight         the Blind                      sim)
                              Forest

  <-- More artistic control           More emergent behavior -->
  <-- More artist labor                More programmer labor -->
  <-- More predictable                 Less predictable       -->
```

Most shipped games sit somewhere in the middle. Even Rain World, the poster child for procedural animation, uses authored textures for creature body segments. Even Stardew Valley, which is almost entirely frame-by-frame, uses procedural touches for things like tool swing arcs and floating item previews.

### Why "Procedural" Does Not Mean "No Art"

This is the most common misconception. Procedural animation does not replace artists. It replaces the **manual positioning** of art.

Consider a character's hair. In a frame-by-frame approach, the artist draws the hair in every single frame -- 4 idle frames, 8 walk frames, 6 attack frames, all multiplied by 4 directions. That is potentially 72 individually drawn hair positions.

In a procedural approach, the artist draws the hair in one or two poses. Code then positions and deforms that hair art dynamically based on the character's movement -- applying spring physics so it trails behind, bouncing when the character lands, blowing in the wind. The result is more varied and responsive than any number of hand-drawn frames, and the artist only needed to draw the hair once.

```
Frame-by-Frame hair:
  Artist draws 72 frames of hair matching body poses.
  Result: Perfect artistic control. Huge labor cost.

Procedural hair:
  Artist draws 1 hair sprite.
  Programmer writes spring physics to position it.
  Result: Infinite variation, reactive to gameplay. Less direct artistic control.

Hybrid hair (Celeste's approach):
  Artist draws the body with frame-by-frame animation.
  Hair is a chain of small sprites, positioned by spring physics.
  Result: Best of both worlds.
```

### Web Development Analogy

If you come from web development, you already understand this spectrum:

| Web Dev Concept | Game Dev Equivalent | Nature |
|-----------------|---------------------|--------|
| CSS `@keyframes` animation | Frame-by-frame sprite animation | Fully pre-made. You author every keyframe. The browser interpolates between them. |
| CSS `transition` | Tweened animation | Semi-pre-made. You define start and end, the browser fills the middle. |
| JS `requestAnimationFrame` loop | Procedural animation | Fully procedural. You compute positions each frame with math. |
| `react-spring` / Framer Motion | Spring physics animation | Physics-based procedural. You define physical properties (stiffness, damping), the library simulates. |
| CSS `cubic-bezier()` timing | Easing functions | You shape *how* interpolation progresses over time. |

The key parallel: in web dev, `react-spring` produces animations that *feel* better than CSS transitions because they respond to interruption naturally (dragging a component mid-animation, for instance). The same principle applies in games -- spring-based procedural motion responds to gameplay events in ways that pre-made animations cannot.

---

## 2. Mathematical Foundations

### Trigonometric Functions

#### The Unit Circle: What sin and cos Actually Represent

The sine and cosine functions come from the unit circle (a circle with radius 1, centered at the origin). Given an angle `theta`:

- `cos(theta)` = the **x-coordinate** of the point on the unit circle at that angle
- `sin(theta)` = the **y-coordinate** of the point on the unit circle at that angle

```
The Unit Circle (radius = 1):

                     (0, 1)
                       |
                  .----+----.
                /      |  /   \          At angle theta:
              /        | /     \           cos(theta) = x projection
             |         |/ theta |          sin(theta) = y projection
   (-1, 0) --+--------â—--------+-- (1, 0)
             |         |        |
              \        |       /
                \      |     /
                  '----+----'
                       |
                     (0, -1)

As theta sweeps from 0 to 2*PI (360 degrees), the point traces the circle.
The x-coordinate (cos) and y-coordinate (sin) each oscillate between -1 and +1.
```

When you plot `sin(theta)` as theta increases over time, you get the classic sine wave:

```
sin(t) over time:

Value
 +1.0 |          *****                              *****
      |       ***     ***                         ***     ***
 +0.5 |     **           **                     **           **
      |   **               **                 **               **
  0.0 |--*-------------------*---------------*-------------------*---
      | *                     *             *                     *
 -0.5 |*                       **         **                       **
      |                          ***   ***                          ***
 -1.0 |                             ***                                *
      +------|-------|-------|-------|-------|-------|-------|-------|----> t
             PI/2    PI     3PI/2   2PI    5PI/2   3PI    7PI/2   4PI
```

This smooth oscillation between -1 and +1 is the building block of almost all procedural animation.

#### Parameters: Amplitude, Frequency, Phase, Offset

The general sine wave formula is:

```
output = offset + amplitude * sin(time * frequency + phase)
```

Each parameter controls a different aspect of the wave:

```
1. AMPLITUDE -- How far the wave swings from center

   amplitude = 1.0:                amplitude = 3.0:
    +1 |    ***                      +3 |    ***
       |  **   **                       |  **   **
    0  |-*-------*---                 0  |-*-------*---
       | *        *                     | *        *
    -1 |*          *                  -3 |*          *

   Amplitude controls the SIZE of the motion.
   For idle bobbing, you might use 1.5 pixels.
   For a dramatic floating effect, maybe 8 pixels.

2. FREQUENCY -- How fast the wave oscillates

   frequency = 1.0:                frequency = 3.0:
    +1 |    ***                      +1 |  ** ** **
       |  **   **                       | * ** ** *
    0  |-*-------*---                 0  |*--*--*--*--*---
       | *        *                     |*  **  * *   *
    -1 |*          *                  -1 | **  **  **

   Higher frequency = faster oscillation.
   Breathing: ~1.5 (slow, relaxed)
   Walking bob: ~8.0 (matches step cadence)
   Vibrating/buzzing: ~30.0 (very fast)

3. PHASE -- Shifts the wave sideways in time

   phase = 0:                      phase = PI (180 degrees):
    +1 |    ***                      +1 |*          *
       |  **   **                       | *        *
    0  |-*-------*---                 0  |--*-------*---
       | *        *                     |    **   **
    -1 |*          *                  -1 |      ***

   Phase shifts WHEN the wave peaks.
   Used to make multiple objects oscillate out of sync.
   If two grass blades have different phase values,
   they sway at the same speed but at different times.

4. OFFSET -- Shifts the wave up or down

   offset = 0:                     offset = 2.0:
    +1 |    ***                      +3 |    ***
       |  **   **                       |  **   **
    0  |-*-------*---                +2  |-*-------*---
       | *        *                     | *        *
    -1 |*          *                  +1 |*          *

   Offset is the "center line" the wave oscillates around.
   For a breathing scale effect, offset = 1.0 (base scale)
   with amplitude = 0.02 gives scale oscillating between 0.98 and 1.02.
```

#### Practical Examples

**Idle bobbing** -- the character gently floats up and down while standing still:

```cpp
// In your entity's update() function:
// totalTime is the accumulated time since the game started (in seconds)
// This produces a gentle 1.5-pixel vertical bob, completing one full
// cycle roughly every 3.1 seconds (2*PI / 2.0 = ~3.14 seconds per cycle)
float bobOffset = sin(totalTime * 2.0f) * 1.5f;

// Apply the offset to the sprite's Y position
// baseY is the character's "real" position -- the bob is purely visual
sprite->setPosition(Vector2(position.x, position.y + bobOffset));
```

**Breathing** -- the character's torso subtly expands and contracts:

```cpp
// Scale the sprite's Y axis to simulate chest expansion
// amplitude is tiny (0.02 = 2% scale change) so it looks subtle
// frequency of 1.5 gives a slow, relaxed breathing rhythm
float breathScale = 1.0f + sin(totalTime * 1.5f) * 0.02f;

// Apply: the sprite is 2% taller at inhale, 2% shorter at exhale
sprite->setSize(Vector2(baseWidth, baseHeight * breathScale));
```

**Floating/hovering** -- an item or fairy bobs more dramatically:

```cpp
// Larger amplitude (4 pixels) and faster frequency (3.0) than idle bobbing
// This creates a clearly visible hover effect
float hoverOffset = sin(totalTime * 3.0f) * 4.0f;
floatingItem->setPosition(Vector2(itemX, itemY + hoverOffset));
```

**Swaying (trees, grass)** -- each instance sways differently thanks to position-based phase:

```cpp
// The key insight: use the object's world X position as a phase offset.
// sin(time * 1.0 + positionX * 0.1) means:
//   - All blades sway at the same speed (frequency = 1.0)
//   - Each blade peaks at a DIFFERENT time (phase = positionX * 0.1)
//   - Blades 10 pixels apart have a phase difference of 1.0 radian
//   - This creates a wave-like pattern across the field
float swayAngle = sin(totalTime * 1.0f + worldX * 0.1f) * 3.0f;

// Apply as rotation around the base of the grass blade
sprite->setRotation(swayAngle);
```

```
Grass field with position-based phase offsets at one moment in time:

    /  |  \  /  |  \  /  |  \  /  |  \
   /   |   \/   |   \/   |   \/   |   \
  /    |    \   |    \   |    \   |    \
========================================= ground

  Each blade has a different tilt because its X position
  shifts the phase of the sine wave. The result looks like
  wind rippling across the field.

  One second later:
    |  \  /  |  \  /  |  \  /  |  \  /
    |   \/   |   \/   |   \/   |   \/
    |    \   |    \   |    \   |    \
  ========================================= ground

  The wave pattern has moved, simulating wind.
```

**Water surface** -- a traveling wave:

```cpp
// For each vertex (or tile column) of the water surface:
// x is the horizontal position of this water segment
// The wave formula creates peaks that travel rightward over time
float waterY = baseWaterY + sin(totalTime * 2.0f + x * 0.5f) * 2.0f;

// To make it more interesting, add a second sine wave with
// different frequency and amplitude (this is additive synthesis):
float waterY = baseWaterY
    + sin(totalTime * 2.0f + x * 0.5f) * 2.0f    // primary wave
    + sin(totalTime * 3.7f + x * 0.8f) * 0.8f;    // secondary ripple
```

#### Combining Sine Waves: The Fourier Intuition

A single sine wave produces motion that looks mechanical and robotic. Real-world motion is always a combination of many oscillations at different speeds.

The key insight from Fourier analysis (you do not need to understand the formal mathematics) is this: **any complex periodic motion can be decomposed into a sum of simple sine waves**. And conversely, **adding multiple sine waves together creates complex, organic-looking motion**.

```
Single sine wave (mechanical):
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Two sine waves added (more organic):
    ~~^~v~~^~~v~^~~v~~^~v~~^~~v~~

Three sine waves added (complex, natural):
    ~^~vv~^~~~v^~v~~^~v~^v~~^~~v

Each added wave has a different frequency and amplitude.
The result is a complex waveform that never exactly repeats
(unless the frequencies are exact integer ratios).
```

In code, this is trivial:

```cpp
// A single sine wave: mechanical
float simple = sin(totalTime * 2.0f) * 3.0f;

// Three sine waves combined: organic
// Each has a different frequency (2.0, 3.3, 5.1) and amplitude (3.0, 1.2, 0.5)
// The irrational frequency ratios mean the combined wave almost never
// repeats exactly, which prevents the motion from looking looped
float organic = sin(totalTime * 2.0f) * 3.0f
              + sin(totalTime * 3.3f) * 1.2f
              + sin(totalTime * 5.1f) * 0.5f;
```

This technique is used everywhere:
- Idle character fidgeting (combine a slow body sway with a faster head tilt)
- Ocean waves (many sines at different frequencies and directions)
- Wind gusts (slow base wind + fast turbulence)
- Camera breathing in cutscenes (subtle multi-frequency drift)

### Noise Functions

#### Why Pure Sine Waves Look Artificial

Sine waves are perfectly smooth and perfectly predictable. After watching a sine-based animation for a few seconds, your brain recognizes the pattern. Real-world motion has randomness -- a tree does not sway in a perfect sine wave because wind is turbulent. A person's idle pose shifts in unpredictable ways because muscles constantly make micro-adjustments.

This is where noise functions come in. They generate **smooth random values** -- random enough to look organic, smooth enough to look natural (no jarring jumps).

#### Perlin Noise

Perlin noise (invented by Ken Perlin in 1983 for the movie Tron) generates smooth pseudorandom values. Conceptually, it works like this:

```
1. Create a grid of random gradient vectors:

   Grid point (0,0): gradient = (0.7, 0.3)
   Grid point (1,0): gradient = (-0.5, 0.8)
   Grid point (0,1): gradient = (0.2, -0.9)
   Grid point (1,1): gradient = (-0.8, -0.4)

2. For any point between grid points, compute
   dot products with the surrounding gradients
   and interpolate smoothly.

3. The result is a continuous function that:
   - Has value 0 at every grid point (approximately)
   - Varies smoothly between grid points
   - Has no visible grid pattern in the output
   - Is deterministic (same input = same output)
```

The output looks like this (1D slice):

```
Pure random (white noise):     Perlin noise (smooth random):
 +1 |* *  * *   *  *          +1 |    ***
    | * **   * *  ** *            |  **   **     **
  0 |---*------*------*--       0 |**-------***--  **---
    |          *       *          |              **    **
 -1 |                             -1 |                  **

White noise: useless for animation    Perlin noise: smooth, organic
(jerky, no continuity)                (continuous, natural-looking)
```

For animation, you sample Perlin noise over time:

```cpp
// Perlin noise takes a position as input and returns a value ~(-1, +1)
// By passing time as the position, you get a smooth random value that
// changes over time
float noiseValue = perlinNoise1D(totalTime * 0.5f);

// Use it to create organic idle fidgeting
float fidgetX = noiseValue * 2.0f;  // up to 2 pixels of random X drift
float fidgetY = perlinNoise1D(totalTime * 0.5f + 100.0f) * 1.5f;
// The +100 offset ensures X and Y use different parts of the noise,
// so they don't move in lockstep

sprite->setPosition(Vector2(baseX + fidgetX, baseY + fidgetY));
```

#### Simplex Noise

Simplex noise (also by Ken Perlin, 2001) is a newer algorithm that produces similar results to Perlin noise but is computationally faster, especially in higher dimensions. For 2D game animation, the difference between Perlin and simplex noise is negligible in both appearance and performance. Use whichever library is available.

#### Comparison: Sine vs. Noise

| Property | sin(time) | Noise(time) |
|----------|-----------|-------------|
| Pattern | Perfectly periodic | Aperiodic (never repeats) |
| Predictability | 100% predictable | Pseudorandom |
| Smoothness | Perfectly smooth | Smooth but irregular |
| Use case | Rhythmic motion (breathing, walking) | Organic motion (wind, idle fidget) |
| Computation cost | Trivially cheap | Slightly more expensive (still cheap) |
| Artistic control | Easy to tune (amplitude, frequency) | Harder to tune (scale, octaves, persistence) |

In practice, you combine both. Use sine waves for the main rhythmic motion, add noise on top for organic variation:

```cpp
// Base breathing rhythm (sine -- predictable, rhythmic)
float breathOffset = sin(totalTime * 1.5f) * 1.5f;

// Organic fidget layered on top (noise -- unpredictable, subtle)
float fidgetOffset = perlinNoise1D(totalTime * 0.3f) * 0.5f;

// Combined: rhythmic breathing with subtle random drift
float finalOffset = breathOffset + fidgetOffset;
```

### Lerp, Smoothstep, and Easing

#### Linear Interpolation (Lerp)

Lerp is the single most used function in all of game development. It blends between two values based on a parameter `t` that ranges from 0 to 1:

```
lerp(a, b, t) = a + (b - a) * t

When t = 0.0: result = a           (fully at start)
When t = 0.5: result = (a+b)/2     (halfway between)
When t = 1.0: result = b           (fully at end)
```

```
Lerp visualization (a = 10, b = 50):

Value
  50 |                              *  b
     |                          *
     |                      *
  30 |                  *
     |              *
     |          *
  10 |      *                          a
     +------+------+------+------+-----> t
            0.0   0.25   0.5   0.75  1.0

Perfectly straight line from a to b.
```

In C++:

```cpp
// The fundamental lerp function
float lerp(float a, float b, float t) {
    return a + (b - a) * t;
}

// Works for Vector2 too -- just lerp each component
Vector2 lerp(Vector2 a, Vector2 b, float t) {
    return Vector2(
        a.x + (b.x - a.x) * t,
        a.y + (b.y - a.y) * t
    );
}
```

**Common use: smooth camera follow.** Instead of the camera snapping to the player's position, you lerp toward it each frame:

```cpp
// Each frame, move the camera 5% of the remaining distance toward the player
// This creates smooth deceleration as the camera approaches
float followSpeed = 5.0f;
cameraPos = lerp(cameraPos, playerPos, followSpeed * deltaTime);

// Why multiply by deltaTime: without it, the camera moves 5% per FRAME,
// which means faster movement at higher frame rates. Multiplying by
// deltaTime makes it frame-rate independent (5% per SECOND instead).
```

This pattern -- `value = lerp(value, target, speed * dt)` -- is called **exponential decay** and is one of the most useful patterns in game programming. It approaches the target asymptotically (never quite reaching it, but getting close enough to be indistinguishable). It handles interruption gracefully -- if the target changes mid-animation, the value smoothly redirects.

In web dev terms, this is what `react-spring` does internally when you change a spring's target value.

#### Smoothstep: Hermite Interpolation

Linear interpolation has a problem: the motion starts and stops abruptly. There is no acceleration at the beginning and no deceleration at the end. The velocity is constant, which looks robotic.

Smoothstep fixes this by using a cubic polynomial that has zero derivative (zero velocity) at both endpoints:

```
smoothstep(t) = t * t * (3 - 2 * t)

         Linear (lerp):               Smoothstep:
Value                              Value
  1 |              *****            1 |                  *****
    |           ***                   |              ****
    |        ***                      |           ***
    |     ***                         |         **
    |  ***                            |      **
  0 |**                             0 |*****
    +----+----+----+----+-->        +----+----+----+----+-->
         0.25 0.5  0.75  1              0.25 0.5  0.75  1

Linear: constant speed.            Smoothstep: eases in and out.
Starts and stops abruptly.         Starts slow, speeds up, ends slow.
```

```cpp
// Smoothstep function
float smoothstep(float t) {
    // Clamp t to [0, 1] for safety
    t = fmax(0.0f, fmin(1.0f, t));
    return t * t * (3.0f - 2.0f * t);
}

// Usage: animate a menu sliding in over 0.5 seconds
float elapsed = currentTime - animationStartTime;
float t = elapsed / 0.5f;  // normalize to 0..1 over half a second
t = smoothstep(t);          // apply easing

float menuX = lerp(offScreenX, onScreenX, t);
```

There is also **smootherstep** (by Ken Perlin), which has zero first AND second derivatives at the endpoints, making it even smoother:

```cpp
float smootherstep(float t) {
    t = fmax(0.0f, fmin(1.0f, t));
    return t * t * t * (t * (t * 6.0f - 15.0f) + 10.0f);
}
```

#### Easing Functions

Easing functions generalize the idea of smoothstep. They all take a linear `t` (0 to 1) and return a curved `t` that creates different motion profiles:

```cpp
// Ease-in: starts slow, ends fast (accelerating)
// Good for: objects falling, things getting sucked in
float easeInQuad(float t) {
    return t * t;
}

float easeInCubic(float t) {
    return t * t * t;
}

// Ease-out: starts fast, ends slow (decelerating)
// Good for: objects coming to rest, things landing
float easeOutQuad(float t) {
    return 1.0f - (1.0f - t) * (1.0f - t);
}

float easeOutCubic(float t) {
    return 1.0f - pow(1.0f - t, 3.0f);
}

// Ease-in-out: slow start, fast middle, slow end
// Good for: camera transitions, UI animations
float easeInOutQuad(float t) {
    if (t < 0.5f) {
        return 2.0f * t * t;
    } else {
        return 1.0f - pow(-2.0f * t + 2.0f, 2.0f) / 2.0f;
    }
}

// Ease-out-back: overshoots the target, then settles
// Good for: bouncy UI, items popping into existence
float easeOutBack(float t) {
    float c1 = 1.70158f;
    float c3 = c1 + 1.0f;
    return 1.0f + c3 * pow(t - 1.0f, 3.0f) + c1 * pow(t - 1.0f, 2.0f);
}

// Ease-out-elastic: springs past the target and oscillates
// Good for: playful UI, cartoon impacts
float easeOutElastic(float t) {
    if (t == 0.0f || t == 1.0f) return t;
    float c4 = (2.0f * M_PI) / 3.0f;
    return pow(2.0f, -10.0f * t) * sin((t * 10.0f - 0.75f) * c4) + 1.0f;
}
```

```
Easing function comparison:

Ease-In (Quad):          Ease-Out (Quad):         Ease-In-Out (Quad):
  1|            **        1|   ****                1|              ***
   |          **            |  **                     |           **
   |        **              | **                      |         **
   |      **                |**                       |      **
   |   **                   |*                        |   **
  0|***                    0|*                       0|***
   +----------->           +----------->              +----------->

Ease-Out-Back:           Ease-Out-Elastic:
  1|     *---*****        1|  * *** ********
   |    * *                 | * * *
   |   *   *               |*   *
   |  *                    |*
   | *                     |*
  0|*                     0|*
   +----------->           +----------->
   (overshoots target)     (oscillates around target)
```

**CSS equivalents:**
- `ease` = roughly `easeInOutCubic`
- `ease-in` = `easeInCubic`
- `ease-out` = `easeOutCubic`
- `ease-in-out` = `easeInOutCubic`
- `cubic-bezier(0.68, -0.55, 0.27, 1.55)` = custom ease with overshoot (like `easeOutBack`)

#### Exponential Decay (The Multiplicative Lerp)

This pattern deserves special attention because it is incredibly useful and often misunderstood:

```cpp
// Each frame, move 5% closer to the target
value = value + (target - value) * 0.05f;

// Equivalent to:
value = lerp(value, target, 0.05f);

// Or equivalently (the "multiply by decay" form):
value = target + (value - target) * 0.95f;
```

This is exponential decay: the remaining distance shrinks by a constant percentage each step. It has two properties that make it perfect for game animation:

1. **It naturally decelerates.** When the value is far from the target, 5% of the distance is a large step. When it is close, 5% of a small distance is a tiny step. Motion feels like it "eases out" automatically.

2. **It handles interruption perfectly.** If the target changes at any moment, the value smoothly redirects. There is no "animation duration" to manage. This is why `react-spring` uses this model internally.

The caveat: **this is frame-rate dependent as written above.** At 60fps, `0.05` per frame means something different than at 30fps. The frame-rate-independent version:

```cpp
// Frame-rate-independent exponential decay
// smoothingFactor controls how fast it converges (higher = faster)
float smoothingFactor = 5.0f;
float alpha = 1.0f - exp(-smoothingFactor * deltaTime);
value = lerp(value, target, alpha);

// exp(-smoothingFactor * deltaTime) is the key:
// - At 60fps: deltaTime = 0.0167, exp(-5 * 0.0167) = 0.920, alpha = 0.080
// - At 30fps: deltaTime = 0.0333, exp(-5 * 0.0333) = 0.846, alpha = 0.154
// The 30fps step is larger, compensating for the longer frame time.
// The net result is identical motion regardless of frame rate.
```

---

## 3. Spring Physics -- Complete Theory and Implementation

### The Physical Model

A spring simulation models a mass attached to a spring that pulls it toward a rest position. The physics involves two forces:

**Hooke's Law (spring force):**
```
F_spring = -k * x

Where:
  k = spring stiffness (how "tight" the spring is)
  x = displacement from rest position (current - rest)
  The negative sign means the force always pulls TOWARD rest.
```

**Damping force (friction):**
```
F_damping = -d * v

Where:
  d = damping coefficient (how much friction)
  v = current velocity
  The negative sign means the force always opposes motion.
```

**Combined:**
```
F_total = -k * x - d * v

Then Newton's second law (F = m * a):
  a = F_total / mass
  v += a * dt
  position += v * dt
```

### Complete Implementation

```cpp
struct Spring {
    float position;     // current value
    float velocity;     // current rate of change
    float target;       // rest position (where the spring pulls toward)

    float stiffness;    // k: how snappy the spring is
    float damping;      // d: how quickly oscillation dies out
    float mass;         // m: how heavy the object is

    Spring(float stiffness, float damping, float mass)
        : position(0.0f)
        , velocity(0.0f)
        , target(0.0f)
        , stiffness(stiffness)
        , damping(damping)
        , mass(mass) {}

    void update(float deltaTime) {
        // Displacement from rest (how far from target)
        float displacement = position - target;

        // Hooke's law: spring force pulls toward target
        float springForce = -stiffness * displacement;

        // Damping force: opposes current velocity (friction)
        float dampingForce = -damping * velocity;

        // Total force
        float totalForce = springForce + dampingForce;

        // Newton's second law: F = ma, so a = F/m
        float acceleration = totalForce / mass;

        // Semi-implicit Euler integration
        // (update velocity first, then use new velocity for position)
        velocity += acceleration * deltaTime;
        position += velocity * deltaTime;
    }

    void setTarget(float newTarget) {
        target = newTarget;
    }

    // Apply an instantaneous impulse (like a hit or landing)
    void impulse(float force) {
        velocity += force / mass;
    }
};
```

### Tuning Parameters

The three parameters (stiffness, damping, mass) give you full control over the spring's behavior:

```
STIFFNESS (k) -- How "tight" the spring is

  Low stiffness (k = 50):          High stiffness (k = 500):
  Lazy, slow pull toward target     Snappy, quick pull toward target

  Position                           Position
    |                                  |
    |  ~~~~~~~~~~~~~~~                 | /\
    | ~               ~~~~~           | /  \/\
    |~                     ~~~~~~     |/     \/\/~~~~~~~~~~~
    +-------------------------->      +-------------------------->
           Time                              Time
  "Jelly-like"                       "Springy metal"


DAMPING (d) -- How quickly oscillation dies

  Low damping (d = 1):              High damping (d = 20):
  Bounces many times                 Settles quickly

  Position                           Position
    |                                  |
    | /\    /\    /\                   | /\
    |/  \  /  \  /  \  /\ /\         |/  \
    |    \/    \/    \/  V  ~~~~      |    \~~~~~~~~
    +-------------------------->      +-------------------------->
           Time                              Time
  "Rubber ball"                      "Shock absorber"


MASS (m) -- How heavy the object is

  Low mass (m = 0.5):               High mass (m = 5.0):
  Responds instantly                 Responds sluggishly

  Position                           Position
    |                                  |
    |/\                                |
    |  \/\                             |    /~~~~~~\
    |    \~~~~                         |   /        \
    +-------------------------->      |  /          ~~~~~~~
           Time                       +-------------------------->
  "Feather"                           "Bowling ball"
```

### Critical Damping, Underdamping, and Overdamping

There is a special damping value called **critical damping** where the spring reaches its target as fast as possible without oscillating. This is calculated from the other parameters:

```
Critical damping = 2 * sqrt(stiffness * mass)

Example: stiffness = 100, mass = 1
  Critical damping = 2 * sqrt(100 * 1) = 2 * 10 = 20
```

The ratio of actual damping to critical damping determines the spring's behavior:

```
damping ratio = d / d_critical

UNDERDAMPED (ratio < 1.0):           d = 5, d_critical = 20, ratio = 0.25
  Oscillates around target, gradually settling.
  Most "fun" for game animation.

  Position
  target -->  ------+----------------------------------
                    |
    | /\            |   /\
    |/  \      /\   |  /  \     /\
    |    \    /  \  | /    \   /  \    /\
    +-----\--/----\-+/------\-/----\--/--\-/~~---> Time
           \/      \/        \/     \/    \/


CRITICALLY DAMPED (ratio = 1.0):     d = 20, d_critical = 20, ratio = 1.0
  Reaches target as fast as possible WITHOUT oscillating.
  Used for camera follow and UI positioning.

  Position
  target -->  ------+-----------~~~~~~~~~~~~~~~~~~~~~
                    |          /
    |               |        /
    |               |      /
    |               |    /
    +---------------+--/-----------------------------> Time
                     /


OVERDAMPED (ratio > 1.0):           d = 50, d_critical = 20, ratio = 2.5
  Returns to target without oscillating, but SLOWER than critical.
  Feels sluggish, rarely desired.

  Position
  target -->  ------+---------------------------~~~~~
                    |                        ~~
    |               |                   ~~
    |               |              ~~
    |               |         ~~
    +---------------+----~~------------------------------> Time

  Note: overdamped is always slower than critically damped.
  There is no benefit to overdamping unless you specifically
  want sluggish, heavy-feeling motion.
```

**Rule of thumb for game animation:**
- Underdamped (ratio 0.3-0.7): Bouncy, playful. Good for UI popups, item pickups, squash-and-stretch.
- Near-critical (ratio 0.8-1.0): Smooth, professional. Good for camera follow, menu transitions.
- Critical (ratio 1.0): Optimal settle time. Good for cursor smoothing, aim assist.

### 2D Springs

To use springs in 2D, simply apply the same spring independently to both the X and Y axes:

```cpp
struct Spring2D {
    Spring x;
    Spring y;

    Spring2D(float stiffness, float damping, float mass)
        : x(stiffness, damping, mass)
        , y(stiffness, damping, mass) {}

    void update(float deltaTime) {
        x.update(deltaTime);
        y.update(deltaTime);
    }

    void setTarget(Vector2 target) {
        x.setTarget(target.x);
        y.setTarget(target.y);
    }

    void impulse(Vector2 force) {
        x.impulse(force.x);
        y.impulse(force.y);
    }

    Vector2 getPosition() const {
        return Vector2(x.position, y.position);
    }
};
```

### Practical Uses

**Squash and stretch on landing:**

```cpp
// When the character lands on the ground after a jump:
// scaleSpringX controls the horizontal scale
// scaleSpringY controls the vertical scale
Spring scaleSpringX(300.0f, 15.0f, 1.0f);  // stiff, moderate damping
Spring scaleSpringY(300.0f, 15.0f, 1.0f);

// Set resting scale to 1.0 (normal size)
scaleSpringX.setTarget(1.0f);
scaleSpringY.setTarget(1.0f);

// On landing, apply a squash impulse:
// Y scale gets compressed (negative impulse = smaller)
// X scale gets stretched (positive impulse = wider)
void onLand(float impactVelocity) {
    float impactForce = impactVelocity * 0.5f;  // scale the effect
    scaleSpringY.impulse(-impactForce);  // squash vertically
    scaleSpringX.impulse(impactForce * 0.5f);  // stretch horizontally
}

// In update():
scaleSpringX.update(deltaTime);
scaleSpringY.update(deltaTime);

// The sprite bounces: squash on impact, overshoot to stretch, settle to 1.0
sprite->setSize(Vector2(
    baseWidth * scaleSpringX.position,
    baseHeight * scaleSpringY.position
));
```

**Camera follow with spring:**

```cpp
// Camera spring: critically damped for smooth, non-bouncy follow
Spring2D cameraSpring(100.0f, 20.0f, 1.0f);  // d = 2*sqrt(100*1) = 20

// Each frame:
cameraSpring.setTarget(playerPosition);
cameraSpring.update(deltaTime);
camera.setPosition(cameraSpring.getPosition());
```

**Hit reaction (enemy knocked back on damage):**

```cpp
// When enemy takes damage:
// Apply an impulse in the direction away from the attacker
Vector2 knockbackDir = normalize(enemyPos - attackerPos);
float knockbackForce = 200.0f;
enemySpring.impulse(Vector2(
    knockbackDir.x * knockbackForce,
    knockbackDir.y * knockbackForce
));
// The spring will pull the enemy back to their original position,
// creating a "recoil" effect
```

**Item pickup pop:**

```cpp
// When an item is picked up, spring the scale from 0 to 1.5 then settle at 0
// (the item visually "pops" before disappearing)
Spring popSpring(200.0f, 10.0f, 1.0f);  // underdamped for bounce
popSpring.position = 0.0f;   // start at scale 0 (invisible)
popSpring.setTarget(0.0f);   // target is 0 (will disappear)
popSpring.impulse(400.0f);   // big impulse makes it pop up to ~1.5 then bounce back to 0
```

---

## 4. Inverse Kinematics (IK) -- Full Explanation

### Forward Kinematics vs. Inverse Kinematics

In a skeletal/bone system, each bone has a parent and a child. **Forward kinematics (FK)** means you set each joint's angle, and the final position of the end effector (hand, foot, tail tip) is calculated from those angles.

**Inverse kinematics (IK)** is the reverse: you specify WHERE you want the end effector to be, and the algorithm calculates what angles the joints need to be at.

```
FORWARD KINEMATICS (FK):

  You set:  shoulder angle = 30 degrees
            elbow angle = -45 degrees

  System computes: hand ends up at position (142, 87)

  "I rotate the joints; the hand goes wherever it goes."


INVERSE KINEMATICS (IK):

  You set:  I want the hand at position (142, 87)

  System computes: shoulder must be 30 degrees
                   elbow must be -45 degrees

  "I say where the hand should be; the joints figure it out."
```

```
FK example -- rotating the shoulder:

  Step 1: Shoulder at 0 deg    Step 2: Shoulder at 45 deg
           (arm points right)           (arm points up-right)

       O                              O
       |                              |
       +----- hand here        +------+
       |                       |
       |                       |
                               hand ends up here

  The hand position is a CONSEQUENCE of the shoulder rotation.


IK example -- placing the hand:

  Step 1: Hand target is here    System calculates joints:

       O                              O
       |                              /\
       |            * target          /  \
       |                             /    * (hand reaches target)
       |                            /
                                   /

  The joint angles are a CONSEQUENCE of the hand target.
```

### Why IK Matters for Games

IK solves problems that FK cannot:

- **Feet on uneven terrain:** Without IK, a character walking up a slope will have feet hovering above or sinking into the ground. With IK, you raycast downward from the hip to find the ground height, then use IK to plant the foot exactly on the surface.

- **Reaching for objects:** A character reaching for a doorknob needs the hand at a specific world position. With FK, you would need a unique animation for every possible doorknob position. With IK, one system handles all positions.

- **Creature legs:** A spider has 8 legs that must all plant on different surfaces. Authoring this as FK animation is infeasible. IK lets each leg independently find its footing.

- **Tails and tentacles:** These need to drape over terrain and react to physics. IK chains solve this naturally.

### Two-Bone Analytical IK

For a chain of exactly two bones (like upper arm + forearm), there is a closed-form mathematical solution. This is the most common IK problem in games.

```
The setup:

  root (shoulder) ---- bone1 (upper arm, length L1) ---- joint (elbow)
                                                           |
                                                      bone2 (forearm, length L2)
                                                           |
                                                        end (hand)

  Given:
    - root position (px, py): where the shoulder is
    - target position (tx, ty): where we want the hand
    - L1: length of bone 1 (upper arm)
    - L2: length of bone 2 (forearm)

  Find:
    - angle1: rotation of bone 1 (shoulder angle)
    - angle2: rotation of bone 2 (elbow angle)
    - joint position: where the elbow ends up
```

**Step 1: Calculate the distance to the target.**

```
dx = tx - px
dy = ty - py
dist = sqrt(dx*dx + dy*dy)
```

**Step 2: Check reachability.**

The arm can only reach targets within a certain range:

```
                           Unreachable (too far):
Reachable zone:            dist > L1 + L2
                           The arm is fully extended and
    +--------+             still cannot reach the target.
   /          \
  /   Shoulder \           In this case, extend the arm
 |    *----*    |          straight toward the target
 |    L1   L2   |          (the best you can do).
  \            /
   \          /            Unreachable (too close):
    +--------+             dist < |L1 - L2|
                           The target is inside the minimum
  Max reach = L1 + L2     reach radius (arm cannot fold
  Min reach = |L1 - L2|   tightly enough to reach it).
```

```cpp
// Check if target is reachable
if (dist > L1 + L2) {
    // Target too far: fully extend arm toward target
    float angle = atan2(dy, dx);
    jointX = px + cos(angle) * L1;
    jointY = py + sin(angle) * L1;
    endX = jointX + cos(angle) * L2;
    endY = jointY + sin(angle) * L2;
    return;
}
if (dist < fabs(L1 - L2)) {
    // Target too close: typically just clamp or skip
    return;
}
```

**Step 3: Law of cosines to find the elbow angle.**

The shoulder, elbow, and target form a triangle with sides L1, L2, and dist:

```
  Shoulder
     *
    / \
L1 /   \ dist
  /     \
 /  a2   \
*---------* Target
 Elbow  L2

The angle at the elbow (between bone1 and bone2) can be found
using the law of cosines:

  dist^2 = L1^2 + L2^2 - 2*L1*L2*cos(elbow_angle)

Solving for elbow_angle:

  cos(elbow_angle) = (L1^2 + L2^2 - dist^2) / (2 * L1 * L2)
  elbow_angle = acos(cos_elbow)
```

```cpp
// Law of cosines for the elbow angle
float cosElbow = (L1 * L1 + L2 * L2 - dist * dist) / (2.0f * L1 * L2);
// Clamp to [-1, 1] to handle floating point imprecision
cosElbow = fmax(-1.0f, fmin(1.0f, cosElbow));
float elbowAngle = acos(cosElbow);
```

**Step 4: Calculate the shoulder angle.**

The shoulder angle has two components: the angle toward the target, and an offset based on the triangle:

```cpp
// Angle from shoulder directly toward target
float angleToTarget = atan2(dy, dx);

// Angle offset at the shoulder within the triangle
// Law of cosines again, this time solving for the shoulder angle
float cosShoulder = (L1 * L1 + dist * dist - L2 * L2) / (2.0f * L1 * dist);
cosShoulder = fmax(-1.0f, fmin(1.0f, cosShoulder));
float shoulderOffset = acos(cosShoulder);

// The shoulder angle is the angle to target PLUS OR MINUS the offset
// The +/- determines which side the elbow bends to (the "elbow flip" problem)
float shoulderAngle = angleToTarget - shoulderOffset;  // or + for the other solution
```

**Step 5: Calculate the joint (elbow) position.**

```cpp
// Elbow position: start from shoulder, go along bone1 direction
float jointX = px + cos(shoulderAngle) * L1;
float jointY = py + sin(shoulderAngle) * L1;

// Hand position: start from elbow, go along bone2 direction
// bone2 angle = shoulderAngle + (PI - elbowAngle)
float bone2Angle = shoulderAngle + (M_PI - elbowAngle);
float handX = jointX + cos(bone2Angle) * L2;
float handY = jointY + sin(bone2Angle) * L2;
```

**The elbow flip problem:**

For any reachable target, there are TWO valid solutions -- the elbow can bend one way or the other:

```
Solution A (elbow UP):          Solution B (elbow DOWN):

     * Elbow                    Shoulder *------+
    / \                                          \
   /   \                                          * Elbow
  /     \                                        /
 *       * Target               * Target        *
 Shoulder                       (same position!)

Both solutions place the hand at the exact same target position.
The choice is aesthetic: for a humanoid arm, you want the elbow
to bend "outward" (away from the body).
```

In the code above, using `angleToTarget - shoulderOffset` vs `angleToTarget + shoulderOffset` selects between these two solutions. For a left arm, you might want one solution; for a right arm, the other.

**Complete two-bone IK function:**

```cpp
struct IKResult {
    Vector2 joint;    // elbow position
    Vector2 end;      // hand position (should match target if reachable)
    float angle1;     // shoulder angle (radians)
    float angle2;     // elbow angle (radians)
    bool reachable;   // whether the target was within reach
};

IKResult solveTwoBoneIK(
    Vector2 root,        // shoulder position
    Vector2 target,      // desired hand position
    float L1,            // upper arm length
    float L2,            // forearm length
    bool elbowUp         // which solution to pick (true = elbow bends upward)
) {
    IKResult result;

    float dx = target.x - root.x;
    float dy = target.y - root.y;
    float dist = sqrt(dx * dx + dy * dy);

    // Check reachability
    if (dist > L1 + L2) {
        // Unreachable: extend fully toward target
        result.reachable = false;
        float angle = atan2(dy, dx);
        result.angle1 = angle;
        result.angle2 = 0.0f;  // fully extended (no bend)
        result.joint = Vector2(
            root.x + cos(angle) * L1,
            root.y + sin(angle) * L1
        );
        result.end = Vector2(
            result.joint.x + cos(angle) * L2,
            result.joint.y + sin(angle) * L2
        );
        return result;
    }

    result.reachable = true;

    // Angle from root directly toward target
    float angleToTarget = atan2(dy, dx);

    // Law of cosines: find the angle at the shoulder within the triangle
    float cosShoulderOffset = (L1 * L1 + dist * dist - L2 * L2)
                            / (2.0f * L1 * dist);
    cosShoulderOffset = fmax(-1.0f, fmin(1.0f, cosShoulderOffset));
    float shoulderOffset = acos(cosShoulderOffset);

    // Law of cosines: find the angle at the elbow
    float cosElbow = (L1 * L1 + L2 * L2 - dist * dist)
                   / (2.0f * L1 * L2);
    cosElbow = fmax(-1.0f, fmin(1.0f, cosElbow));
    float elbowAngle = acos(cosElbow);

    // Choose which side the elbow bends to
    if (elbowUp) {
        result.angle1 = angleToTarget - shoulderOffset;
    } else {
        result.angle1 = angleToTarget + shoulderOffset;
    }
    result.angle2 = elbowAngle;

    // Calculate joint (elbow) position
    result.joint = Vector2(
        root.x + cos(result.angle1) * L1,
        root.y + sin(result.angle1) * L1
    );

    // Calculate end (hand) position
    float bone2Angle = result.angle1 + (M_PI - elbowAngle);
    if (!elbowUp) {
        bone2Angle = result.angle1 - (M_PI - elbowAngle);
    }
    result.end = Vector2(
        result.joint.x + cos(bone2Angle) * L2,
        result.joint.y + sin(bone2Angle) * L2
    );

    return result;
}
```

### Multi-Bone IK: Why Analytical Solutions Do Not Scale

For a chain of 3 or more bones, there is no single closed-form solution. A 3-bone chain has infinitely many valid configurations for any reachable target (think of how many ways you can bend your arm + wrist to touch a point). You need iterative algorithms that converge toward a good solution.

### FABRIK Algorithm

FABRIK (Forward And Backward Reaching Inverse Kinematics) is an elegant iterative algorithm. It works for chains of any length and is simple to understand and implement.

**The idea:** Alternate between two passes:
1. **Forward pass:** Start from the end effector, move each joint toward the target, preserving bone lengths.
2. **Backward pass:** Start from the root (which may have drifted), move each joint back toward the root, preserving bone lengths.

Repeat until the end effector is close enough to the target (or a maximum iteration count is reached).

```
Initial state (3-bone chain, target is the star):

  Root                                                    * Target
    O---------O---------O---------O
   J0         J1         J2        J3 (end)

  The end (J3) is far from the target.


FORWARD PASS (work from end toward root):

  Step 1: Move J3 to the target
    O---------O---------O         * J3 (moved to target)
   J0         J1         J2

  Step 2: Move J2 toward new J3, maintaining bone length
    O---------O         O---------* J3
   J0         J1        J2 (adjusted)

  Step 3: Move J1 toward new J2, maintaining bone length
    O         O---------O---------* J3
   J0        J1 (adjusted)

  After forward pass: J0 has drifted from its fixed root position!


BACKWARD PASS (work from root toward end):

  Step 1: Move J0 back to root position (it is pinned)
    O         O---------O---------* J3
   J0 (fixed)

  Step 2: Move J1 toward J0, maintaining bone length
    O---------O         O---------* J3
   J0        J1 (adjusted)

  Step 3: Move J2 toward J1, maintaining bone length
    O---------O---------O         * J3
   J0                   J2 (adjusted)

  Step 4: Move J3 toward J2, maintaining bone length
    O---------O---------O---------* J3
   J0                              (closer to target now!)


After one iteration, J3 is closer to the target but not there yet.
Repeat forward + backward passes until J3 is close enough.
Typically converges in 3-10 iterations.
```

```cpp
struct FABRIKChain {
    std::vector<Vector2> joints;     // joint positions
    std::vector<float> boneLengths;  // distance between consecutive joints
    float tolerance;                 // how close the end must be to the target
    int maxIterations;               // prevent infinite loops

    FABRIKChain(std::vector<Vector2> initialJoints, float tolerance, int maxIterations)
        : joints(initialJoints)
        , tolerance(tolerance)
        , maxIterations(maxIterations)
    {
        // Calculate bone lengths from initial positions
        for (size_t i = 0; i < joints.size() - 1; i++) {
            float dx = joints[i + 1].x - joints[i].x;
            float dy = joints[i + 1].y - joints[i].y;
            boneLengths.push_back(sqrt(dx * dx + dy * dy));
        }
    }

    void solve(Vector2 target) {
        int numJoints = joints.size();
        if (numJoints < 2) return;

        // Save root position (it is pinned)
        Vector2 rootPos = joints[0];

        // Check if target is reachable
        float totalLength = 0.0f;
        for (float len : boneLengths) {
            totalLength += len;
        }
        float dx = target.x - rootPos.x;
        float dy = target.y - rootPos.y;
        float distToTarget = sqrt(dx * dx + dy * dy);

        if (distToTarget > totalLength) {
            // Target is unreachable: extend chain straight toward target
            float angle = atan2(dy, dx);
            for (int i = 1; i < numJoints; i++) {
                joints[i] = Vector2(
                    joints[i - 1].x + cos(angle) * boneLengths[i - 1],
                    joints[i - 1].y + sin(angle) * boneLengths[i - 1]
                );
            }
            return;
        }

        // Iterative solve
        for (int iteration = 0; iteration < maxIterations; iteration++) {
            // Check if end effector is close enough to target
            Vector2 end = joints[numJoints - 1];
            float endDx = end.x - target.x;
            float endDy = end.y - target.y;
            float endDist = sqrt(endDx * endDx + endDy * endDy);
            if (endDist < tolerance) {
                break;  // close enough
            }

            // FORWARD PASS: move end to target, work backward
            joints[numJoints - 1] = target;
            for (int i = numJoints - 2; i >= 0; i--) {
                // Direction from joint[i] to joint[i+1]
                float dirX = joints[i].x - joints[i + 1].x;
                float dirY = joints[i].y - joints[i + 1].y;
                float dirLen = sqrt(dirX * dirX + dirY * dirY);

                // Avoid division by zero
                if (dirLen < 0.0001f) {
                    dirX = 0.0f;
                    dirY = 1.0f;
                    dirLen = 1.0f;
                }

                // Normalize direction and place joint at bone length distance
                dirX /= dirLen;
                dirY /= dirLen;
                joints[i] = Vector2(
                    joints[i + 1].x + dirX * boneLengths[i],
                    joints[i + 1].y + dirY * boneLengths[i]
                );
            }

            // BACKWARD PASS: pin root back, work forward
            joints[0] = rootPos;
            for (int i = 1; i < numJoints; i++) {
                // Direction from joint[i] to joint[i-1]
                float dirX = joints[i].x - joints[i - 1].x;
                float dirY = joints[i].y - joints[i - 1].y;
                float dirLen = sqrt(dirX * dirX + dirY * dirY);

                if (dirLen < 0.0001f) {
                    dirX = 0.0f;
                    dirY = 1.0f;
                    dirLen = 1.0f;
                }

                dirX /= dirLen;
                dirY /= dirLen;
                joints[i] = Vector2(
                    joints[i - 1].x + dirX * boneLengths[i - 1],
                    joints[i - 1].y + dirY * boneLengths[i - 1]
                );
            }
        }
    }
};
```

### CCD (Cyclic Coordinate Descent)

CCD is another iterative IK algorithm with a different approach. Instead of moving joints along the chain, it **rotates** each joint to point its sub-chain toward the target:

```
CCD algorithm (one iteration):

Start from the LAST joint before the end effector, work toward root.

Step 1: Rotate J2 so that J3 points toward the target
  Before:                    After:
    O----O----O----O            O----O----O
   J0   J1   J2   J3          J0   J1   J2\
                    * Target                 \J3
                                              * Target (closer!)

Step 2: Rotate J1 so that J3 points toward the target
  (Now J3 is in a different position due to step 1)
  Rotate J1, which swings J2 and J3 together toward the target.

Step 3: Rotate J0 so that J3 points toward the target
  Same idea: rotate the root, which swings the entire chain.

Repeat for multiple iterations until J3 reaches the target.
```

CCD tends to produce "whip-like" motion because the end joints rotate more than the root joints. This can be desirable for tentacles and tails, but looks unnatural for arms. FABRIK generally produces more natural-looking results for humanoid limbs.

### Practical 2D Examples

**Spider/insect legs:**

```
Each leg has:
  - A hip joint (attached to the body)
  - A knee joint
  - A foot (end effector)

The foot has a "target" position on the ground.
When the body moves, the foot stays planted (IK keeps it on the ground).
When the foot gets too far from the body, it picks up and moves
to a new target position (a step).

   Body moves right -->

   Before step:              During step:           After step:
       ____                      ____                   ____
      |    |                    |    |                  |    |
      |____|                    |____|                  |____|
     /      \                  /      \                /      \
    /        \                /   ___--\              /        \
   *          *              *  /       \            *          *
 (planted)  (planted)     (planted) (lifting)    (planted)  (new target)

IK calculates joint angles so feet stay on the ground surface.
```

**Tails and tentacles:**

```
A tail is a FABRIK chain that "follows" the body:

  The root is pinned to the character's rear.
  Gravity pulls the joints downward.
  There is no "target" per se -- you let the chain drape naturally.

  Standing still:      Running right:        Jumping:
       O                   O                    O
       |                  /                     |
       |                 /                      |
       |                / (trailing behind)     |
       .               .                         \
                                                   \ (trailing down)
                                                    .
```

For tails, you do not use IK to reach a target. Instead, you update the root joint each frame (pinning it to the character), apply gravity to all other joints, and use the FABRIK backward pass to maintain bone lengths. The tail naturally trails behind the character.

---

## 5. Verlet Integration and Rope/Chain Physics

### What Verlet Integration Is

Most physics simulations track position AND velocity as separate values (Euler integration). Verlet integration takes a different approach: it tracks the **current position** and the **previous position**. Velocity is implicit -- it is the difference between the current and previous positions.

```
Euler integration (what Spring uses):
  velocity += acceleration * dt
  position += velocity * dt

  Stores: position, velocity
  Velocity is EXPLICIT

Verlet integration:
  newPosition = position + (position - oldPosition) + acceleration * dt^2
  oldPosition = position
  position = newPosition

  Stores: position, oldPosition
  Velocity is IMPLICIT (position - oldPosition)
```

Why is this useful? Because Verlet integration is **trivially easy to constrain.** If you move a particle to satisfy a constraint (like a fixed distance from another particle), its "velocity" automatically adjusts for the next frame because velocity is derived from position. In Euler integration, moving a particle to satisfy a constraint would make the velocity inconsistent, causing jitter and explosions.

### Why Verlet is Perfect for Chains, Ropes, and Cloth

Chains, ropes, and cloth are collections of points connected by fixed-distance constraints. The simulation loop is:

1. Apply forces (gravity, wind) to each point using Verlet integration
2. Apply constraints: adjust point positions to maintain fixed distances
3. Repeat constraint step multiple times for stability

```
A rope with 5 points and 4 distance constraints:

  Point 0 (pinned to ceiling)
    |
    | constraint: dist = 10
    |
  Point 1
    |
    | constraint: dist = 10
    |
  Point 2
    |
    | constraint: dist = 10
    |
  Point 3
    |
    | constraint: dist = 10
    |
  Point 4 (free end, affected by gravity)
```

### The Verlet Update

```cpp
struct VerletPoint {
    Vector2 position;
    Vector2 oldPosition;
    bool pinned;          // pinned points don't move (attached to something)
    float mass;

    VerletPoint(Vector2 pos, bool pinned = false, float mass = 1.0f)
        : position(pos)
        , oldPosition(pos)
        , pinned(pinned)
        , mass(mass) {}

    void update(float deltaTime, Vector2 gravity) {
        if (pinned) return;  // pinned points are immovable

        // Calculate implicit velocity (current - previous position)
        Vector2 velocity = Vector2(
            position.x - oldPosition.x,
            position.y - oldPosition.y
        );

        // Save current position as the new "old" position
        oldPosition = position;

        // Verlet integration: new position = current + velocity + acceleration * dt^2
        // acceleration = gravity (could add wind here too)
        position.x += velocity.x + gravity.x * deltaTime * deltaTime;
        position.y += velocity.y + gravity.y * deltaTime * deltaTime;
    }

    // Apply damping (air resistance) by shrinking the implicit velocity
    void applyDamping(float damping) {
        if (pinned) return;
        // Move oldPosition closer to position, which shrinks the velocity
        oldPosition.x = position.x - (position.x - oldPosition.x) * damping;
        oldPosition.y = position.y - (position.y - oldPosition.y) * damping;
    }
};
```

### Distance Constraints

A distance constraint says: "these two points must be exactly `restLength` apart." If they are not, both points are moved toward or away from each other until the distance is correct.

```cpp
struct DistanceConstraint {
    int indexA;         // index of first point
    int indexB;         // index of second point
    float restLength;   // how far apart they should be

    DistanceConstraint(int a, int b, float length)
        : indexA(a), indexB(b), restLength(length) {}

    void solve(std::vector<VerletPoint>& points) {
        VerletPoint& a = points[indexA];
        VerletPoint& b = points[indexB];

        // Current distance between the two points
        float dx = b.position.x - a.position.x;
        float dy = b.position.y - a.position.y;
        float currentDist = sqrt(dx * dx + dy * dy);

        // Avoid division by zero
        if (currentDist < 0.0001f) return;

        // How much the distance differs from the rest length
        float difference = (currentDist - restLength) / currentDist;

        // Move each point half the correction distance
        // (If one is pinned, the other moves the full amount)
        float moveFactorA = a.pinned ? 0.0f : 0.5f;
        float moveFactorB = b.pinned ? 0.0f : 0.5f;

        // If one is pinned, the other must take the full correction
        if (a.pinned && !b.pinned) {
            moveFactorB = 1.0f;
        } else if (b.pinned && !a.pinned) {
            moveFactorA = 1.0f;
        }

        float correctionX = dx * difference;
        float correctionY = dy * difference;

        a.position.x += correctionX * moveFactorA;
        a.position.y += correctionY * moveFactorA;
        b.position.x -= correctionX * moveFactorB;
        b.position.y -= correctionY * moveFactorB;
    }
};
```

### Iterative Constraint Solving

After one pass of constraint solving, some constraints may have been violated by solving other constraints. The solution: run the constraint pass multiple times. More iterations = more accurate (stiffer rope).

```
Iteration 1:
  Constraint A-B satisfied, but this moves B, violating B-C.
  Constraint B-C satisfied, but this moves C, violating C-D.
  ... (cascading errors)

Iteration 2:
  Errors from iteration 1 are much smaller.
  Re-solving all constraints reduces the remaining error.

Iteration 5:
  Errors are negligibly small. The rope looks correct.

Rule of thumb:
  3-5 iterations: loose rope (some stretching visible)
  8-15 iterations: stiff rope (minimal stretching)
  20+ iterations: very rigid (like a solid chain)
```

### Complete Rope/Chain System

```cpp
struct VerletChain {
    std::vector<VerletPoint> points;
    std::vector<DistanceConstraint> constraints;
    int constraintIterations;   // how many times to solve constraints per frame

    VerletChain(
        Vector2 startPos,       // where the chain starts (pinned point)
        int numPoints,          // how many points in the chain
        float segmentLength,    // distance between consecutive points
        int iterations          // constraint solver iterations
    ) : constraintIterations(iterations) {
        // Create points in a vertical line below the start
        for (int i = 0; i < numPoints; i++) {
            Vector2 pos = Vector2(startPos.x, startPos.y + i * segmentLength);
            bool isPinned = (i == 0);  // only the first point is pinned
            points.push_back(VerletPoint(pos, isPinned));
        }

        // Create distance constraints between consecutive points
        for (int i = 0; i < numPoints - 1; i++) {
            constraints.push_back(DistanceConstraint(i, i + 1, segmentLength));
        }
    }

    void update(float deltaTime, Vector2 gravity, Vector2 wind) {
        // Step 1: Apply forces and update positions (Verlet integration)
        for (auto& point : points) {
            Vector2 totalAcceleration = Vector2(
                gravity.x + wind.x,
                gravity.y + wind.y
            );
            point.update(deltaTime, totalAcceleration);
            point.applyDamping(0.99f);  // slight air resistance
        }

        // Step 2: Solve constraints (multiple iterations for stability)
        for (int iter = 0; iter < constraintIterations; iter++) {
            for (auto& constraint : constraints) {
                constraint.solve(points);
            }
        }
    }

    void setAnchorPosition(Vector2 pos) {
        // Move the pinned point (e.g., attached to a character's head)
        points[0].position = pos;
        points[0].oldPosition = pos;  // prevent implicit velocity from the move
    }
};
```

### How Celeste's Hair Works

Celeste's iconic hair trail is a chain of Verlet-style points:

```
Celeste's hair system:

  1. The first point is pinned to Madeline's head
  2. Each subsequent point follows the one before it
  3. When Madeline moves, the pinned point moves with her
  4. The chain naturally trails behind due to the lag of physics
  5. Each point is rendered as a small circle (sprite)
  6. The color of each point changes based on dash state

  Standing still:         Running right:        Dashing:
       *  (head)               * (head)           * (head)
       *                      *                   *  *  *  * (stretched out)
       *                     *
       *                    *  (trailing behind)
       * (tail)            *

The physics are simple Verlet with distance constraints.
The visual impact is enormous -- it makes the character feel
alive and responsive, conveying speed and momentum at a glance.
```

The actual implementation is essentially the `VerletChain` described above, with each point rendered as a circle sprite whose radius decreases toward the tail end. The color of all points changes when Madeline dashes (red when she has a dash available, blue when dashes are spent).

---

## 6. Particle-Like Procedural Effects

These techniques are not full particle systems (which manage thousands of particles with emitters, lifetimes, and pooling), but they use procedural animation to create lightweight visual effects.

### Trail Effects

Store the last N positions of a moving object and render them as a trail:

```cpp
struct Trail {
    std::vector<Vector2> positions;   // circular buffer of recent positions
    int maxLength;                     // how many positions to store
    int head;                          // current write index

    Trail(int length)
        : maxLength(length)
        , head(0) {
        positions.resize(length, Vector2(0.0f, 0.0f));
    }

    void recordPosition(Vector2 pos) {
        positions[head] = pos;
        head = (head + 1) % maxLength;
    }

    // Render: draw lines or sprites from newest to oldest position
    // with decreasing opacity
    void render(Shader& shader, const Camera& camera) {
        for (int i = 0; i < maxLength; i++) {
            // Calculate the age of this point (0 = newest, maxLength-1 = oldest)
            int index = (head - 1 - i + maxLength) % maxLength;
            float age = static_cast<float>(i) / static_cast<float>(maxLength);

            // Older points are more transparent
            float alpha = 1.0f - age;

            // Draw a sprite at this position with the computed alpha
            // (You would set a uniform for opacity in your shader)
            Vector2 pos = positions[index];
            // ... render sprite at pos with alpha opacity ...
        }
    }
};
```

```
Trail effect over several frames:

  Frame 1:  *
  Frame 2:  o *           (o = previous position, faded)
  Frame 3:  . o *         (. = older position, more faded)
  Frame 4:    . o *       (oldest position dropped)
  Frame 5:      . o *

  The trail creates a sense of speed and direction.
```

### Afterimage / Ghost Effect

Similar to trails, but you render the **full sprite** (not just a dot) at previous positions with decreasing opacity:

```
Afterimage during a dash:

  Frame:  [faint] [medium] [strong] [SOLID]
            @@       @@       @@      @@
           @  @     @  @     @  @    @  @
           @  @     @  @     @  @    @  @
            @@       @@       @@      @@

  Each "ghost" is the same sprite drawn with lower and lower alpha.
  Creates a "speed blur" effect common in action games.
```

The implementation is the same as the trail, but instead of drawing dots, you draw the full sprite at each recorded position. You might only record a ghost every few frames (not every frame) to keep them spaced apart.

### Dust Puffs on Landing

When a character lands after a jump, spawn a few small sprites with procedural motion:

```cpp
struct DustParticle {
    Vector2 position;
    Vector2 velocity;
    float lifetime;       // seconds remaining
    float maxLifetime;    // total seconds alive
    float scale;          // size

    bool isAlive() const {
        return lifetime > 0.0f;
    }

    void update(float deltaTime) {
        lifetime -= deltaTime;

        // Apply velocity
        position.x += velocity.x * deltaTime;
        position.y += velocity.y * deltaTime;

        // Apply gravity (light, since dust floats)
        velocity.y += 20.0f * deltaTime;

        // Slow down horizontally (air resistance)
        velocity.x *= (1.0f - 2.0f * deltaTime);

        // Scale shrinks as particle ages
        float lifeRatio = lifetime / maxLifetime;
        scale = lifeRatio * 0.5f;  // shrinks to zero
    }
};

// When landing, create 3-5 dust particles:
void spawnLandingDust(Vector2 feetPosition) {
    for (int i = 0; i < 4; i++) {
        DustParticle dust;
        dust.position = feetPosition;

        // Random horizontal velocity (spread left and right)
        float spreadAngle = -M_PI + (static_cast<float>(rand()) / RAND_MAX) * M_PI;
        float speed = 30.0f + (static_cast<float>(rand()) / RAND_MAX) * 40.0f;
        dust.velocity = Vector2(cos(spreadAngle) * speed, sin(spreadAngle) * speed - 20.0f);

        dust.maxLifetime = 0.3f + (static_cast<float>(rand()) / RAND_MAX) * 0.2f;
        dust.lifetime = dust.maxLifetime;
        dust.scale = 0.3f;

        // Add to a list of active particles
        activeDustParticles.push_back(dust);
    }
}
```

```
Dust puff over time:

  Frame 1 (impact):     Frame 3:           Frame 5:           Frame 8:
                          .   .
       [LAND]            . [LAND] .          .   .              (faded away)
  ==================    ==================   ==================  ==================
                        Dust spreads out     Dust rises and
                        from impact point    shrinks, fading
```

These effects are small in code but large in impact. A few particles at the right moments (landing, running, sliding) make a game feel significantly more polished.

---

## 7. Hybrid Approaches: Procedural + Pre-Made

### The Practical Sweet Spot

Pure procedural animation is a massive undertaking (see Rain World below). Pure frame-by-frame animation is labor-intensive and static. The practical sweet spot is **frame-by-frame base animation with procedural enhancements layered on top.**

This is what most modern 2D games do, even if they do not advertise it. Celeste, Hollow Knight, Dead Cells, Katana Zero -- all use hand-drawn base animations with procedural polish.

### What to Make Procedural

These elements benefit from being procedural because they need to react to gameplay or vary naturally:

| Element | Technique | Why Procedural |
|---------|-----------|----------------|
| Hair / cape physics | Spring chain or Verlet chain | Must react to movement direction, speed, wind |
| Idle breathing | Sine wave on Y scale | Too subtle to hand-animate; would look stiff without variation |
| Squash and stretch | Spring on X/Y scale | Must react to landing velocity, which varies |
| Weapon sway | Sine wave on rotation | Adds life during idle without requiring extra frames |
| Eye tracking | Lerp rotation toward look target | Must follow NPCs, cursor, or points of interest |
| Shadow scale during jumps | Lerp scale based on height | Shadow shrinks as character rises, grows as they land |
| Screen shake on impact | Noise-based camera offset | Intensity varies with damage; too dynamic to pre-author |
| Footfall dust | Small procedural particles | Landing velocity varies; position depends on terrain |
| Water ripples | Sine wave displacement | Must react to player position, which is dynamic |

### What to Keep Pre-Made

These elements are better as frame-by-frame because artistic intent and precise timing matter more than dynamic variation:

| Element | Why Pre-Made |
|---------|--------------|
| Walk cycles | Complex body mechanics with weight shifts, anticipation, and overlap. Procedural walk cycles for humanoids are extremely difficult to make look good. |
| Attack sequences | Precise timing matters for game feel. The "windup-strike-recovery" rhythm must be hand-tuned. |
| Facial expressions | Artistic intent is everything. A smirk vs. a smile is a 1-pixel difference that only an artist can judge. |
| Death animations | Dramatic, authored moments that define a game's personality. |
| Emotes and gestures | Communication clarity matters. Must be instantly readable. |
| Victory/defeat poses | Characterization moments that define personality. |

### Case Studies of Games That Mix Both

**Celeste:**
- Pre-made: All body animations (run, climb, dash, die)
- Procedural: Hair (Verlet chain), dust particles, screen shake, squash/stretch on landing, afterimages during dash

**Hollow Knight:**
- Pre-made: All character animations, enemy behavior animations
- Procedural: Cloth cape (spring-based), particle effects (soul, infection), screen shake, boss camera effects

**Dead Cells:**
- Pre-made: All combat animations (pre-rendered from 3D, hand-painted)
- Procedural: Trail effects behind weapons, blood splatter trajectories, screen shake and freeze frames on critical hits

**Katana Zero:**
- Pre-made: Run, slash, and death animations
- Procedural: Afterimage trails, bullet-time slow motion, screen distortion effects, blood particle physics

**Stardew Valley:**
- Pre-made: All character animations, tool usage, farming actions
- Procedural: Floating item preview (sine bob), fishing line (simple physics), rain/snow particles, crop sway (sine with position-based phase)

The pattern is clear: **body animation is pre-made, everything else is procedural.** This is because the human body is the hardest thing to animate procedurally (we are extremely attuned to whether body movement looks "right"), while environmental effects and accessories are much more forgiving.

---

## 8. Case Study: Rain World (Deep Analysis)

Rain World (2017, developed primarily by Joar Jakobsson over 6+ years) is the most ambitious procedural animation system in any 2D game. Understanding how it works -- and why it took so long -- is essential context for any game developer considering procedural animation.

### How Every Creature is a Physics Simulation

In Rain World, there are no sprite sheets for creature animations. Every creature is a collection of **body points** (physics-simulated particles) connected by **springs and constraints.** The visual appearance is generated from these body point positions every frame.

```
A Slugcat (the player character) in Rain World:

  Body points (simplified):

       (head)
         O
        / \
       /   \          Each O is a physics point with:
      O     O           - position
     (arms)              - velocity
       \   /             - gravity
        \ /              - collision with terrain
         O
       (torso)         Springs connect them:
        / \              - head to torso (fixed distance)
       /   \             - arms to torso (flexible)
      O     O            - legs to torso (flexible)
     (legs)

  The "animation" is the physics simulation:
  - Walking: legs push against ground, body tilts
  - Climbing: arms grip terrain, body hangs
  - Falling: all points affected by gravity
  - Swimming: drag force replaces gravity

  No two walks are the same because the physics state
  is always slightly different.
```

### Springs and Constraints in Detail

The creature body is held together by:

1. **Distance springs:** Keep body points at specific distances (torso length, arm length). These are the "bones" of the creature, but they are flexible springs, not rigid bones.

2. **Angle constraints:** Some joints have limits on how far they can bend. A knee cannot bend backward (unless the creature is dead/ragdoll).

3. **Muscle forces:** Active forces that the creature's AI applies to specific body points. Walking is not an animation -- it is the AI applying alternating forces to the left and right leg points, pushing against the ground.

4. **Terrain collision:** Each body point collides with the tilemap. Points slide along surfaces and grip ledges. This is why creatures can climb on anything and squeeze through gaps.

### The Rendering Pipeline

After the physics simulation determines all body point positions:

1. Curves are computed between body points (catmull-rom splines for smooth shapes)
2. Textures are mapped onto these curves (stretching and deforming)
3. The visual shape of the creature is generated from the spline positions
4. Additional details (eyes, markings) are positioned relative to body points

The result is a creature that looks hand-animated but is actually a real-time physics simulation.

### Why It Took 6+ Years

The difficulty of Rain World's approach is not in the physics code (which is relatively straightforward Verlet-style simulation). The difficulty is in **tuning.** Every creature in Rain World has dozens of parameters:

- Spring stiffnesses for every connection
- Damping values for every joint
- Muscle force strengths and patterns for locomotion
- Collision response behaviors
- AI decision-making that produces natural-looking movement

Getting a creature to walk, climb, swim, fight, and die in a way that looks natural and behaves correctly in ALL terrain configurations requires months of iteration per creature type.

### Emergent Behavior

The most remarkable aspect of Rain World's system is emergent behavior -- animations that the developer never explicitly programmed:

- Creatures slip on wet surfaces because friction parameters change
- Long creatures drape over edges because gravity pulls unsupported body points down
- Predators' hunting movements vary based on terrain, creating the illusion of intelligence
- Injured creatures limp because reduced muscle forces create asymmetric locomotion

These behaviors emerge from the physics simulation. The developer did not animate "slipping" or "limping" -- the physics produces them naturally.

### Why This is NOT Appropriate for Most Games

Rain World's approach is extraordinary, but it comes with severe trade-offs:

1. **Development time:** 6+ years, primarily solo. Most indie games ship in 2-3 years with a team.

2. **Unpredictability:** Physics simulations produce unexpected results. A creature might get stuck in terrain, vibrate wildly, or move in an unintended way. Every edge case must be addressed individually.

3. **Art direction difficulty:** You cannot tell a physics simulation "I want the character to pose like this." The simulation produces whatever the physics dictate. Achieving a specific look requires careful parameter tuning, not direct artistic control.

4. **Pixel art incompatibility:** Procedural deformation of pixel art tends to produce blurry, messy results. Rain World uses high-resolution art pieces that tolerate stretching and rotation. For your project (pixel art Stardew Valley style), this approach would conflict with the aesthetic.

5. **Scope creep:** Once you start simulating physics, every new creature or interaction requires physics parameters, collision handling, and edge case fixes. The scope of work grows non-linearly.

**The lesson:** Rain World proves that procedural animation can produce extraordinary results. It also proves that achieving those results is a multi-year endeavor requiring a specific game design that embraces emergent physics. For most projects, a hybrid approach (pre-made base + procedural polish) achieves 90% of the benefit at 10% of the cost.

---

## 9. Case Study: Noita

Noita (2019, Nolla Games) takes procedural animation to a different extreme: instead of simulating creature bodies, it simulates the **entire world** at a per-pixel level.

### Per-Pixel Physics Simulation

Every pixel in Noita's world is a physical material: sand, water, lava, wood, metal, acid, blood, fire, smoke, oil. Each pixel has material properties (density, flammability, viscosity, conductivity) and follows cellular automata rules to simulate physics:

```
Noita's pixel simulation (simplified):

Each frame, for every pixel:

  Sand:    Falls down. If blocked, slides diagonally.
  Water:   Falls down. If blocked, spreads horizontally.
  Fire:    Rises up. Ignites adjacent flammable pixels.
  Wood:    Static. Catches fire when adjacent to fire.
  Acid:    Falls down. Dissolves adjacent solid pixels.
  Lava:    Falls down (slowly). Ignites everything. Turns to rock when cooled.
  Smoke:   Rises up. Dissipates over time.
  Oil:     Falls down. Floats on water. Very flammable.

Frame 1:          Frame 10:         Frame 50:
  [FIRE]            [SMOKE]          [SMOKE] [SMOKE]
  [WOOD]            [FIRE]           [        ]
  [OIL]             [WOOD]           [        ]
  [WATER]           [OIL ON FIRE]    [WATER BOILING]
                    [WATER]          [STEAM RISING]

The wood catches fire, the fire ignites the oil,
the burning oil heats the water, the water turns to steam.
All of this is emergent behavior from simple per-pixel rules.
```

### Procedural Destruction and Material Interaction

In Noita, terrain is not a static tilemap -- it is a live simulation. Explosions do not play a pre-made animation; they apply forces to pixels, sending them flying according to physics. Acid does not have a "dissolving" animation; it chemically reacts with adjacent pixels frame by frame.

This means animation in Noita is the physics simulation itself:
- A bridge collapsing is sand pixels losing support and cascading downward
- A fire spreading is fire pixels igniting adjacent wood pixels
- A flood is water pixels filling a cavity shaped by the terrain

### How Animation Emerges from the Simulation

Creatures in Noita are also partially simulated. When an enemy dies, its body pixels become physical materials (blood, meat, bone) that interact with the world. A worm digging through terrain actually removes terrain pixels, creating tunnels that water can flow through later.

The "animations" are:
- Explosions: radial force applied to nearby pixels + spawning fire/smoke pixels
- Creature death: body converts to material pixels, subject to gravity and physics
- Spells: complex interactions between spawned material pixels (acid rain, lava bombs, freeze spells)
- Environmental events: chain reactions of materials interacting

### Performance Implications

Simulating millions of pixels per frame is extremely expensive. Noita uses several optimizations:

1. **Chunked simulation:** The world is divided into chunks. Only chunks near the player are fully simulated. Distant chunks are "frozen."

2. **Material-specific update order:** Heavy materials (sand) are processed bottom-to-top so they fall correctly. Light materials (smoke) are processed top-to-bottom.

3. **GPU rendering:** The simulation runs on the CPU (cellular automata are difficult to parallelize on GPU), but the rendering of the pixel world uses the GPU.

4. **Sparse updates:** Stationary pixels (a settled pile of sand) do not need to be processed. Only pixels that changed recently or have active neighbors are updated.

Even with these optimizations, Noita struggles with performance during large chain reactions (a common player complaint). This is the cost of simulating a world at per-pixel granularity.

**The lesson for your engine:** Noita's approach is fascinating but irrelevant for a Stardew Valley-style game. You are using a tile-based world, not a pixel-simulated one. However, individual Noita-like effects (a small area of sand physics, water flowing through tiles) could be implemented as localized simulations within your tile system. This is scope you would add much later, if at all.

---

## 10. Implementation Patterns for Your Engine

### How Procedural Animation Fits Your Existing Architecture

Your engine has this rendering flow:

```
Entity.update(deltaTime)           Sprite.draw(shader, camera)
  |                                   |
  v                                   v
  Updates position, state           Builds model matrix from
  based on game logic               position, size, rotation
                                      |
                                      v
                                    Sends uniforms to shader
                                      |
                                      v
                                    GPU draws the quad
```

Procedural animation slots in **between Entity.update() and Sprite.draw()** -- it modifies the sprite's position, size, and rotation before the sprite is rendered.

```
Entity.update(deltaTime)
  |
  v
ProceduralAnimator.update(deltaTime)   <-- NEW: modifies sprite properties
  |
  v
Sprite.draw(shader, camera)
  |
  v
  (sprite uses modified position/size/rotation)
```

### ProceduralAnimator Concept

A `ProceduralAnimator` manages all procedural effects for a single entity. It applies sine offsets, spring effects, and other modifications to the sprite before rendering:

```cpp
class ProceduralAnimator {
private:
    // Time tracking
    float totalTime;

    // Sine-based effects
    float bobAmplitude;     // idle bob amount (pixels)
    float bobFrequency;     // idle bob speed
    float breathAmplitude;  // breathing scale amount
    float breathFrequency;  // breathing speed

    // Spring effects
    Spring scaleSpringX;    // horizontal squash/stretch
    Spring scaleSpringY;    // vertical squash/stretch
    Spring2D positionSpring; // position offset (hit reactions, etc.)

    // Base values (what the entity "wants" to be)
    Vector2 basePosition;
    Vector2 baseSize;
    float baseRotation;

public:
    ProceduralAnimator()
        : totalTime(0.0f)
        , bobAmplitude(1.5f)
        , bobFrequency(2.0f)
        , breathAmplitude(0.02f)
        , breathFrequency(1.5f)
        , scaleSpringX(300.0f, 15.0f, 1.0f)
        , scaleSpringY(300.0f, 15.0f, 1.0f)
        , positionSpring(100.0f, 18.0f, 1.0f)
        , basePosition(0.0f, 0.0f)
        , baseSize(32.0f, 48.0f)
        , baseRotation(0.0f)
    {
        // Springs rest at neutral (scale = 1.0, offset = 0)
        scaleSpringX.position = 1.0f;
        scaleSpringX.setTarget(1.0f);
        scaleSpringY.position = 1.0f;
        scaleSpringY.setTarget(1.0f);
    }

    void update(float deltaTime) {
        totalTime += deltaTime;

        // Update springs
        scaleSpringX.update(deltaTime);
        scaleSpringY.update(deltaTime);
        positionSpring.update(deltaTime);
    }

    // Apply all procedural effects to a sprite
    void applyToSprite(Sprite* sprite) {
        // Start from base values
        float finalX = basePosition.x;
        float finalY = basePosition.y;
        float finalW = baseSize.x;
        float finalH = baseSize.y;

        // Apply idle bob (sine wave on Y position)
        finalY += sin(totalTime * bobFrequency) * bobAmplitude;

        // Apply breathing (sine wave on Y scale)
        float breathFactor = 1.0f + sin(totalTime * breathFrequency) * breathAmplitude;
        finalH *= breathFactor;

        // Apply spring-based scale (squash/stretch from landings, hits, etc.)
        finalW *= scaleSpringX.position;
        finalH *= scaleSpringY.position;

        // Apply spring-based position offset (hit reactions, etc.)
        finalX += positionSpring.getPosition().x;
        finalY += positionSpring.getPosition().y;

        // Set the sprite's transform
        sprite->setPosition(Vector2(finalX, finalY));
        sprite->setSize(Vector2(finalW, finalH));
    }

    // Trigger effects
    void onLand(float impactVelocity) {
        float force = impactVelocity * 0.3f;
        scaleSpringY.impulse(-force);  // squash
        scaleSpringX.impulse(force * 0.5f);  // stretch wide
    }

    void onHit(Vector2 knockbackDirection) {
        positionSpring.impulse(Vector2(
            knockbackDirection.x * 100.0f,
            knockbackDirection.y * 100.0f
        ));
    }

    void onItemPickup() {
        // Quick scale pop
        scaleSpringX.impulse(50.0f);
        scaleSpringY.impulse(50.0f);
    }

    void setBasePosition(Vector2 pos) { basePosition = pos; }
    void setBaseSize(Vector2 size) { baseSize = size; }
    void setBaseRotation(float rot) { baseRotation = rot; }
};
```

### Integration with the Entity System

In your current architecture, `Entity` has a `Sprite*` and calls `sprite->draw()`. The ProceduralAnimator would be owned by the entity and applied in the render step:

```cpp
class Player : public Entity {
private:
    ProceduralAnimator animator;

public:
    void update(float deltaTime) override {
        // Game logic: movement, input, state changes
        handleInput(deltaTime);
        updatePosition(deltaTime);

        // Tell the animator where the entity "really" is
        animator.setBasePosition(position);
        animator.setBaseSize(Vector2(sprite->getSize()));

        // Update procedural effects
        animator.update(deltaTime);
    }

    void render(Shader& shader, const Camera& camera) override {
        // Apply procedural effects to sprite before drawing
        animator.applyToSprite(sprite.get());

        // Draw the sprite (now with procedural modifications applied)
        sprite->draw(shader, camera);
    }

    void onLand(float velocity) {
        animator.onLand(velocity);
    }

    void onDamage(Vector2 attackerPos) {
        Vector2 knockback = Vector2(
            position.x - attackerPos.x,
            position.y - attackerPos.y
        );
        // Normalize
        float len = sqrt(knockback.x * knockback.x + knockback.y * knockback.y);
        if (len > 0.0f) {
            knockback.x /= len;
            knockback.y /= len;
        }
        animator.onHit(knockback);
    }
};
```

### Performance Considerations

Procedural animation calculations are trivially cheap on modern hardware:

| Operation | Cost per Entity per Frame |
|-----------|---------------------------|
| `sin()` call | ~10 nanoseconds |
| Spring update (3 multiplies, 2 adds) | ~5 nanoseconds |
| Verlet point update | ~10 nanoseconds |
| FABRIK iteration (5-bone chain) | ~100 nanoseconds |
| Perlin noise sample | ~50 nanoseconds |

For context, your GPU spends ~10,000 nanoseconds per draw call, and you have a 16,000,000 nanosecond budget per frame at 60fps. Even with 100 entities, each with a 10-bone IK chain and 5 springs, the total CPU cost of procedural animation is roughly 0.01% of your frame budget.

The bottleneck in 2D games is almost always draw calls and GPU fill rate, never procedural animation math. Do not worry about performance when adding sine waves, springs, or even small Verlet chains.

### When to Start Simple

A practical progression for adding procedural animation to your engine:

```
Stage 1: Sine waves only
  - Idle bob on Y position
  - Breathing scale on Y
  - Floating items
  - Grass/tree sway with position-based phase
  Time to implement: ~1 hour
  Visual impact: noticeable polish

Stage 2: Add springs
  - Squash/stretch on landing
  - Hit reaction knockback
  - Camera follow smoothing
  - Item pickup pop
  Time to implement: ~2-3 hours
  Visual impact: significant "game feel" improvement

Stage 3: Add easing functions
  - Menu transitions
  - Dialogue box appearance
  - Health bar changes
  - Smooth fade-in/fade-out
  Time to implement: ~1 hour
  Visual impact: professional UI feel

Stage 4: Add Verlet chains
  - Hair/cape on player character
  - Hanging ropes/vines in environments
  - Necklaces or pendants on characters
  Time to implement: ~4-6 hours
  Visual impact: distinctive, memorable character design

Stage 5: Add IK (if needed)
  - Creature legs planting on terrain
  - Hands reaching for objects
  - Tentacle enemies
  Time to implement: ~8-12 hours
  Visual impact: highly situational (worth it for creature-heavy games)
```

Start with Stage 1 and 2. These alone will make your game feel dramatically more polished than a game with no procedural animation. Stages 4 and 5 are specialized tools you add when you have a specific need for them.

---

## Glossary

| Term | Definition |
|------|-----------|
| **Procedural animation** | Animation generated by algorithms at runtime, not from pre-made frames |
| **Amplitude** | The maximum displacement of an oscillation from its center |
| **Frequency** | How many oscillation cycles occur per unit of time |
| **Phase** | The offset of an oscillation in time; shifts when the wave peaks |
| **Perlin noise** | A smooth pseudorandom function used for organic-looking variation |
| **Lerp** | Linear interpolation: blending between two values based on a 0-1 parameter |
| **Smoothstep** | A cubic interpolation function with zero velocity at start and end |
| **Easing** | Functions that shape how interpolation progresses over time |
| **Exponential decay** | A pattern where a value approaches a target by a fixed percentage each step |
| **Spring** | A physics model where force is proportional to displacement from rest |
| **Hooke's law** | F = -kx; the spring force equation |
| **Stiffness (k)** | How strongly a spring pulls toward rest position |
| **Damping (d)** | How quickly a spring's oscillation dies out |
| **Critical damping** | The exact damping value where a spring settles without oscillating |
| **Underdamped** | Damping below critical; the spring oscillates before settling |
| **Overdamped** | Damping above critical; the spring returns slowly without oscillating |
| **FK (Forward Kinematics)** | Setting joint angles and computing end position |
| **IK (Inverse Kinematics)** | Setting end position and computing joint angles |
| **Two-bone IK** | Analytical IK solution for a chain of exactly two bones |
| **FABRIK** | Forward And Backward Reaching Inverse Kinematics; iterative multi-bone IK algorithm |
| **CCD** | Cyclic Coordinate Descent; another iterative IK algorithm |
| **Verlet integration** | Position-based physics integration using current and previous position |
| **Distance constraint** | A rule that two points must maintain a fixed distance |
| **Constraint iteration** | Repeated application of constraints for accuracy; more iterations = stiffer |
| **Afterimage** | Drawing faded copies of a sprite at previous positions for speed effect |
| **Squash and stretch** | Deforming a sprite's scale to convey impact and elasticity |
| **Fourier series** | The mathematical principle that complex waves are sums of simple sine waves |
